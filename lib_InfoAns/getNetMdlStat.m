function NetStat = getNetMdlStat(nSpk, popVec, parsMdl, NetStat)
% Calculate the statistics of samples generated by the network, and the
% statistics of single neuron's responses.

% Note that popVec and nSpk are cells
% with each element the results in a single trial under a parameters set

% Wen-Hao Zhang, July 19, 2019
% wenhao.zhang@pitt.edu
% University of Pittsburgh


%% Statistics of decoder's output (the position on the ring manifold)
[tSample, ~, meanSample, covSample] = popVectorDecoder(popVec, parsMdl);

if parsMdl.numNets == 1
    % Calculate the covariance of posterior p(s,z|x).
    % The reason of doing this is that once I use spiking ufwd, the recorded
    % distribution will become p(s,z|s_ext) instead of p(s,z|x). Thus I find
    % the covariance of posterior in a parametric way.
    if parsMdl.bSample_ufwd && (covSample(4,4) ~= 0)
        covPostSample = covSample(1:2,1:2) - covSample(1,4)^2/ covSample(4,4);
        NetStat.covPostSample = covPostSample;
    end
else
    numNets = parsMdl.numNets;    
    meanSample = meanSample(1:numNets); % Only the first numNets are the mean of stim. feature samples
    
    if isfield(NetStat, 'covCondMean')
        NetStat.covCondMean = covSample(numNets+1:end, numNets+1:end);
    end
    covSample = covSample(1:numNets, 1:numNets);
    NetStat.meanSamplePred = covSample * NetStat.PreMat_LH * parsMdl.Posi;
end

% Fold analyzed results into a struct
NetStat.tSample     = tSample;
NetStat.meanSample  = meanSample;
NetStat.covSample   = covSample;

%% Statistics of neuronal activity

% Mean population firing rate
ratePop = squeeze(mean(nSpk,2))/parsMdl.tTrial*1e3;

if parsMdl.numNets > 1
   ratePop = reshape(ratePop, parsMdl.Ne, parsMdl.numNets); 
end
% Get the width and height of population firing rate
% [~, tuneWidth, rateHeight] = getPopRateMetric(ratePop);
tuneParams = lsFitTuneFunc(ratePop, parsMdl); % [Height, posi, Width, Bias]

if parsMdl.numNets == 1
    % Mean firing rate across neurons and across trials
    rateAvg = squeeze(mean(nSpk(:)))/parsMdl.tTrial*1e3;
    
    % Correlation coefficient of spike count
    corr_r = corr(nSpk');
    corr_r = corr_r - diag(diag(corr_r));
    corrAvg = mean(corr_r(~isnan(corr_r)), 'all');
    
    % Fold analyzed results into a struct
    NetStat.ratePop     = ratePop;
    NetStat.rateAvg     = rateAvg;
    NetStat.corrAvg     = corrAvg;
    NetStat.rateHeight  = tuneParams(1);
    NetStat.ratePosi    = tuneParams(2);
    NetStat.tuneWidth   = tuneParams(3);
    NetStat.rateOffset  = tuneParams(4);
else
    NetStat.ratePop     = ratePop;
    NetStat.rateHeight  = tuneParams(1,:);
end


end